#include<iostream>
#include<cstdlib>
using namespace std;
//Node structure for Ride Requests


class Date {
private:
	int month;
	int date;
	int year;
public:
	Date() {
		month = 0;
		year = 0;
		date = 0;
	}

	Date(int date, int month, int year) {
		this->date = date;
		this->month = month;
		this->year = year;
	}
	void Display() {
		cout << endl << "Date: " << date << "/" << month << "/" << year << endl;
	}


	bool operator<(const Date& b) const {
		if (this->year < b.year) {
			return true;
		}
		else if (this->year == b.year) {
			if (this->month < b.month) {
				return true;
			}
			else if (this->month == b.month) {
				if (this->date < b.date) {
					return true;
				}
			}
		}

		return false;
	}


};
class Ride {
private:
	string customerName;
	string pickup;
	string dropoff;
	float fare;
	Date date;
public:
	Ride() {
		customerName = "";
		this->pickup = "";
		dropoff = "";
		this->fare = 0;
		date = Date();
	}
	Ride(string cname, string pickup, string drop, float fare, Date date) {

		customerName = cname;
		this->pickup = pickup;
		dropoff = drop;
		this->fare = fare;

		this->date = date;
	}
	//Getters
	string getCustomerName() {
		return customerName;
	}
	string getDropOffLocation() {
		return dropoff;
	}
	string getPickUPLocation() {
		return pickup;
	}
	Date& getDate() {
		return date;
	}
	float getFare() {
		return fare;
	}

	virtual void Display() {
		date.Display();
		cout << "\nCustomer Name: " << getCustomerName() << endl;
		cout << "\nPickup Location: " << getPickUPLocation() << endl;
		cout << "\nDropoff Location: " << getDropOffLocation() << endl;
		cout << "\nFare: " << getFare() << endl;
		cout << "---------------------------";
	}
};
class RideRequest : public Ride {
	//making a template for displaying the lists makes sense cosidering the only major difference in the code will be
	//of the object's own display function
	int requestID;
public:

	RideRequest() {
		requestID = 0;
	}
	RideRequest(int id, string cname, string pickup, string drop, float fare, Date date) : Ride(cname, pickup, drop, fare,date) {
		requestID = id;
	}

	int getRideRequestID() {
		return requestID;
	}

	void Display() override {
		cout << "\n----------------\nRequest ID: " << requestID << endl;
		Ride::Display();// this saves sooo much time tho
	}


};

// Node structure for Active Rides
class ActiveRide : public Ride {
	int rideID;
	string driverName;
public:
	// active rides objectss are created when a request is accepted
	//its existence depends upon RideRequest
	//ActiveRide(int id, string driverName, string cname, string pickup, string drop, float fare) : Ride(cname, pickup, drop, fare){
	//	rideID = id;
	//	this->driverName = driverName;
	//}
	ActiveRide() : Ride() {
		rideID = 0;
		driverName = "";
	}
	ActiveRide(int id, string driverName, RideRequest& obj) : Ride(obj.getCustomerName(), obj.getDropOffLocation(), obj.getDropOffLocation(), obj.getFare(), obj.getDate()) {
		rideID = id;
		this->driverName = driverName;
	}


	void Display() override {
		cout << endl << "----------------\nRide ID: " << rideID << endl << "Driver Name: " << driverName << endl;
		Ride::Display();

	}

	int getrideID() {
		return rideID;
	}
	string getdriverName() {
		return driverName;
	}

};
// Node structure for Ride History
class RideHistory : public Ride {
	int rideID;
	string driverName;
	bool status; // Completed or Canceled
public:
	RideHistory() : Ride() {
		rideID = 0;
		driverName = "";
		status = "";
	}
	RideHistory(bool status, int id, string driverName, string cname, string pickup, string drop, float fare,Date date) : Ride(cname, pickup, drop, fare, date) {
		rideID = id;
		this->driverName = driverName;
		this->status = status;
	}

	RideHistory(int id, RideRequest& obj) : Ride(obj.getCustomerName(), obj.getPickUPLocation(), obj.getDropOffLocation(), obj.getFare(), obj.getDate()) {
		// status will be cancelled
		//driver will not be assigned
		rideID = id;
		status = 0;
		driverName = "Not assigned";
	}


	RideHistory(bool status, int id, ActiveRide& obj) : Ride(obj.getCustomerName(), obj.getPickUPLocation(), obj.getDropOffLocation(), obj.getFare(), obj.getDate()) {
		// status will be cancelled
		//driver will not be assigned
		rideID = id;
		this->status = status;
		driverName = obj.getdriverName();
	}

	void Display() override {
		cout << endl << "----------------\nRide ID: " << rideID << endl << "Driver Name: " << driverName << endl << "Ride status: " << status;
		if (status) cout << "Completed";
		else cout << endl << "Cancelled" << endl;
		Ride::Display();

	}

	int getrideID() {
		return rideID;
	}
	string getdriverName() {
		return driverName;
	}
	bool getStatus() {
		return status;
	}


};






template<typename T>
class Node {
public:
	T obj;
	Node<T>* next;


	Node() {
		next = nullptr;
	}
	Node(T val) {
		obj = val;
		next = nullptr;
	}



};


class GenericLinkList {
protected:
	template<typename T>
	bool isEmpty(Node<T>* header) {
		return header == nullptr;
	}

	template<typename T>
	void AddAtEnd(Node<T>*& header, Node<T>*& tail, T obj) {
		Node<T>* temp = new Node<T>(obj);
		if (header == nullptr) {
			header = tail = temp;
		}
		else {
			tail->next = temp;
			tail = temp;
		}
	}

	template<typename T>
	void DeleteFromStart(Node<T>*& header, Node<T>*& tail) {
		if (header == nullptr) {
			return;
		}
		else if (header->next == nullptr) {
			delete header;
			header = tail = nullptr;
		}
		else {
			Node<T>* temp = header;
			header = header->next;
			delete temp;

		}
	}



	template<typename T>
	void Display(Node<T>* header, Node<T>* tail) {
		static_assert(
			is_same_v<T, RideRequest> ||
			is_same_v<T, ActiveRide> ||
			is_same_v<T, RideHistory>,
			"Type not supported"
			);


		if (header == nullptr) {
			cout << endl << "Empty!" << endl;
			return;
		}
		Node<T>* temp = header;
		Ride* ptr;
		while (temp != nullptr) {
			ptr = &temp->obj;
			ptr->Display();

			temp = temp->next;
		}
		//ptr = &temp->obj;
		//ptr->Display();

	}



	template<typename T>
	void Destructor(Node<T>*& header, Node<T>*& tail) {
		if (isEmpty(header)) {
			return;
		}
		Node<T>* current = header->next;
		Node<T>* prev = header;
		if (header->next == nullptr) {
			delete header;

			header = tail = nullptr;
		}
		else {

			while (current->next != nullptr) {
				delete prev;
				prev = current;
				current = current->next;


			}
		}






	}






	// Helper functions that cannot be generalized

};

class RideNowSystem : protected GenericLinkList {
private:
	Node<RideRequest>* requestHead;
	Node<ActiveRide>* activeHead;
	Node<RideHistory>* historyHead;

	Node<RideRequest>* requestTail;
	Node<ActiveRide>* activeTail;
	Node<RideHistory>* historyTail;



	Node<RideRequest>* getRequest(int id) { // make the delete function here for the time being
		if (isEmpty(requestHead)) {
			cout << endl << "Error! List empty";
		}
		else if (requestHead->obj.getRideRequestID() == id) {
			return requestHead;
		}
		else if (requestTail->obj.getRideRequestID() == id) {
			return requestTail;
		}
		else {
			if (requestHead->next == nullptr) {
				cout << endl << "List does not contain value";
				return nullptr;
			}
			Node<RideRequest>* temp = requestHead->next;
			while (temp->next != nullptr) {
				if (temp->obj.getRideRequestID() == id) {
					return temp;
				}
				temp = temp->next;
			}

			return nullptr;



		}
	}
	Node<RideRequest>* PopRequest(int id) {
		if (isEmpty(requestHead)) {
			cout << endl << "Error! List empty";
		}
		if (requestHead->obj.getRideRequestID() == id) {
			if (requestHead->next == nullptr) {
				Node<RideRequest>* temp = requestHead;
				requestHead = requestTail = nullptr;
				return temp;
			}
		}
		else {
			if (requestHead->next == nullptr) {
				cout << endl << "List does not contain value";
				return nullptr;
			}
			Node<RideRequest>* prev = requestHead;
			Node<RideRequest>* curr = requestHead->next;
			while (curr != nullptr) {
				if (curr->obj.getRideRequestID() == id) {
					prev->next = curr->next;
					Node<RideRequest>* temp = curr;
					return temp;
				}
				else {
					prev = curr;
					curr = curr->next;
				}
			}
			cout << endl << "Couldn't  delete";
			return nullptr;



		}
	}
	Node<ActiveRide>* getActiveRides(int id) {
		if (isEmpty(activeHead)) {
			cout << endl << "Error! List empty";
			return nullptr;
		}
		else if (activeHead->obj.getrideID() == id) {
			if (activeHead->next == nullptr) {
				Node<ActiveRide>* temp = activeHead;
				activeHead = activeTail = nullptr;
				return temp;
			}
			else {
				Node<ActiveRide>* temp = activeHead;
				activeHead = temp->next;
				return temp;
			}
		}
		else {

			if (activeHead->next == nullptr) {
				cout << endl << "List does not contain value";
				return nullptr;
			}
			Node<ActiveRide>* prev = activeHead;
			Node<ActiveRide>* curr = activeHead->next;
			while (curr != nullptr) {
				if (curr->obj.getrideID() == id) {
					prev->next = curr->next;
					return curr;
				}
				else {
					prev = curr;
					curr = curr->next;
				}
			}
			cout << endl << "Couldn't  delete";
			return nullptr;



		}

	}

	bool isRequestIDUnique(int id) {
		if (isEmpty(requestHead)) {
			return true;
		}
		else if (requestTail->obj.getRideRequestID() == id) {
			return false;
		}

		Node<RideRequest>* temp = requestHead;
		while (temp->next != nullptr) {
			if (temp->obj.getRideRequestID() == id) {
				return false;
			}
			temp = temp->next;
		}
		return true;


	}
	bool isRideIDUnique_Active(int id) {
		if (isEmpty(activeHead)) {
			return true;
		}
		else if (activeTail->obj.getrideID() == id) {
			return false;
		}

		Node<ActiveRide>* temp = activeHead;
		while (temp->next != nullptr) {
			if (temp->obj.getrideID() == id) {
				return false;
			}
			temp = temp->next;
		}
		return true;
	}
	bool isRideIDUnique_History(int id) {
		if (isEmpty(activeHead)) {
			return true;
		}
		else if (activeTail->obj.getrideID() == id) {
			return false;
		}

		Node<ActiveRide>* temp = activeHead;
		while (temp->next != nullptr) {
			if (temp->obj.getrideID() == id) {
				return false;
			}
			temp = temp->next;
		}
		return true;
	}


	template<typename T>
	void Swap(Node<T>* a, Node<T>* b) {
		T dt = a->obj;
		a->obj = b->obj;
		b->obj = dt;

	}


public:
	RideNowSystem() {
		requestHead = requestTail = nullptr;
		activeHead = activeTail = nullptr;
		historyHead = historyTail = nullptr;

	}


	int getUniqueID(int& id) {
		if (isRequestIDUnique(id)) {
			return id;
		}
		else {
			do {
				cout << endl << "ID must be unique. Please try again:";
				cin >> id;
			} while (!isRequestIDUnique(id));
			return id;
		}
	}





	///
	// ========== Ride Request Functions ==========
	void addRideRequest(int id, string cname, string pickup, string drop, float fare, Date date) {
		AddAtEnd<RideRequest>(requestHead, requestTail, RideRequest(id, cname, pickup, drop, fare, date));
	}
	void displayRideRequests() {
		Display<RideRequest>(requestHead, requestTail);
	}

	void cancelRideRequest(int id) {// did not make generic function because the paremeters for delete by value are different
		if (isEmpty(requestHead)) {
			cout << endl << "List Empty! Cannot delete";
			return;
		}

		bool deleted = false;

		if (requestHead->obj.getRideRequestID() == id) {
			AddAtEnd<RideHistory>(historyHead, historyTail, RideHistory(0, requestHead->obj));
			if (requestHead->next == nullptr) {
				delete requestHead;
				requestHead = requestTail = nullptr;
				deleted = true;
			}
			else {
				Node<RideRequest>* temp = requestHead;
				requestHead = requestHead->next;
				delete temp;
			}

		}
		else {
			Node<RideRequest>* curr = requestHead->next;
			Node<RideRequest>* prev = requestHead;

			while (curr != nullptr) {
				if (curr->obj.getRideRequestID() == id) {
					prev->next = curr->next;
					AddAtEnd<RideHistory>(historyHead, historyTail, RideHistory(0, curr->obj));
					delete curr;
					cout << endl << "Request Cancelled";
					return;
				}
				prev = curr;
				curr = curr->next;
			}
			cout << endl << "Value not found!";

		}


	}


	//
	//// ========== Active Ride Functions ==========National University of Computer and Emerging Sciences,
	void assignRideToDriver(int id, string driverName) {
		Node<RideRequest>* temp = PopRequest(id);
		if (temp != nullptr) {
			AddAtEnd<ActiveRide>(activeHead, activeTail, ActiveRide(id, driverName, temp->obj));
			cout << endl << "Rider assigned!";
		}
		else {
			cout << endl << " Ride does not exist!";
		}
	}
	void displayActiveRides() {
		cout << endl << "Active Rides List:\n";
		Display<ActiveRide>(activeHead, activeTail);
	}
	//// ========== Ride History Functions ==========
	void completeRide(int id, bool completed) {
		Node<ActiveRide>* temp = getActiveRides(id);
		if(temp != nullptr){
			AddAtEnd<RideHistory>(historyHead, historyTail, RideHistory(completed, id, temp->obj));
		}
		
	}
	void displayRideHistory() {
		Display<RideHistory>(historyHead, historyTail);
	}
	void searchRideByCustomer(string cname) {
		if (isEmpty(historyHead)) {
			cout << endl << "List empty";
			return;
		}

		Node<RideHistory>* temp = historyHead;
		bool found = false;
		while (temp != nullptr) {
			if (temp->obj.getCustomerName() == cname) {
				cout << endl << "Ride found!\nRide Details:";
				temp->obj.Display();
				found = true;
			}
			temp = temp->next;
		}
		if (!found) {
			cout << endl << "Ride not found";
		}
	}
	void calculateTotalRevenue() { // this could've been float but the skeleton made it void
		float rev = 0;
		if (isEmpty(historyHead)) {
			cout << endl << "Total Revenue: " << rev;
		}
		else if (historyHead->next == nullptr) {
			rev = historyHead->obj.getFare();
		}
		else {
			Node<RideHistory>* temp = historyHead;
			while (temp != nullptr) {
				rev += temp->obj.getFare();
				temp = temp->next;
			}
		}

		cout << endl << "Total Revenue: " << rev;
	}
	//// ========== Advanced Functionalities ==========
	void sortRideHistoryByFare() {
		if (isEmpty(historyHead)) {
			cout << endl << "History List empty";
			return;
		}

		Node<RideHistory>* max = historyHead;
		while (max->next != nullptr) {
			Node<RideHistory>* max2 = historyHead;
			while (max2->next != nullptr) {
				if (max2->obj.getFare() < max2->next->obj.getFare()) {
					Swap(max2, max2->next);
				}
				max2 = max2->next;
			}
			max = max->next;
		}
	}
	void reverseRideHistory() {
		if (isEmpty(historyHead)) {
			cout << endl << "History List empty";
			return;
		}

		Node<RideHistory>* max = historyHead;
		while (max->next != nullptr) {
			Node<RideHistory>* max2 = historyHead;
			while (max2->next != nullptr) {
				if (max2->obj.getDate().operator<(max2->next->obj.getDate())) {

					Swap(max2, max2->next);
				}
				max2 = max2->next;
			}
			max = max->next;
		}
	
	}


void deleteOldRidesByDate( Date date) {
		if (isEmpty(historyHead)) {
			cout << endl << "List empty!";
			return;
		}
	headlabel:
		Node<RideHistory>* temp = historyHead;
		while (temp != nullptr) {
			if (temp == historyHead && temp->obj.getDate() < date) {
				DeleteFromStart<RideHistory>(historyHead, historyTail);
			}
			else {
				break;
			}
		}
		Node<RideHistory>* prev = historyHead;
		Node<RideHistory>* curr = nullptr;
		if(prev != nullptr)curr = prev->next;

		while (curr != nullptr) {
			if (historyHead->obj.getDate() < date) {
				goto headlabel;
			}
			if (curr->obj.getDate() < date) {
				prev->next = curr->next;
				delete curr;
				curr = prev->next;
			}
			else {
				prev = curr;
				curr = curr->next;
			}
		}


	}
	// Extra challenge
	void findLongestRide() {
		if (isEmpty(historyHead)) {
			cout << endl << "No rides";
		}
		int max = 0;
		Node<RideHistory>* temp = historyHead;
		Node<RideHistory>* mak = historyHead;
		string str = "";

		while (temp != nullptr) {
			str.append(temp->obj.getPickUPLocation());
			str.append(temp->obj.getDropOffLocation());
			if (str.size() > max) {
				mak = temp;
				max = str.size();
			}
			str.clear();
			temp = temp->next;
		}

		cout << endl << "Longest Ride:";
		mak->obj.Display();

	}

	void detectAndMergeDuplicateRequests() {
		if (isEmpty(requestHead)) {
			cout << endl << "List empty!";
			return;
		}
		Node<RideRequest>* temp = requestHead;

		while (temp != nullptr) {
			Node<RideRequest>* prev = temp;
			Node<RideRequest>* curr = temp->next;

			while (curr != nullptr) {
				if (curr->obj.getPickUPLocation() == temp->obj.getPickUPLocation() &&
					curr->obj.getDropOffLocation() == temp->obj.getDropOffLocation() &&
					curr->obj.getCustomerName() == temp->obj.getCustomerName()) {
					prev->next = curr->next;
					delete curr;
					curr = prev->next;
				}
				else {
					prev = curr;
					curr = curr->next;
				}
			}

			temp = temp->next;
		}
	}


	~RideNowSystem() {
	
		if (!isEmpty(requestHead))Destructor<RideRequest>(requestHead, requestTail);
		if (!isEmpty(activeHead))Destructor<ActiveRide>(activeHead, activeTail);
		if (!isEmpty(historyHead))Destructor<RideHistory>(historyHead, historyTail);
	}
};

int main() {

	RideNowSystem system2;
	system2.addRideRequest(1, "A", "jijij", "dgndlfgn", 55, Date(2,12,2000));
	system2.addRideRequest(2, "B", "adfasdf", "jfgndfg", 23, Date(3,1,2001));
	system2.addRideRequest(3, "C", "astolfo", "andfjgn", 99 ,Date(5, 1, 2001));
	system2.addRideRequest(4, "D", "sdfasdf", "jndfijg", 6, Date(8, 11, 2002));
	system2.addRideRequest(5, "E", "jijij", "dgndlfgn", 5, Date(9, 1, 2004));

	Date bb(9, 11, 2001);
	Date flash(1, 2, 2002);

	cout << endl << (flash < bb);






	int choice;
	do {
		cout << "\n====== RideNow System Menu ======\n";
		cout << "1. Add Ride Request\n";
		cout << "2. Cancel Ride Request\n";
		cout << "3. Assign Ride to Driver\n";
		cout << "4. Complete Ride\n";
		cout << "5. Display Current Ride Requests\n";
		cout << "6. Display Active Rides\n";
		cout << "7. Display Ride History\n";
		cout << "8. Search Rides by Customer\n";
		cout << "9. Calculate Total Revenue\n";
		cout << "10. Sort Ride History by Fare\n";
		cout << "11. Reverse Ride History\n";
		cout << "12. Detect & Merge Duplicate Ride Requests\n";
		cout << "13. Delete Old Rides by Date\n";
		cout << "14. Find Longest Ride\n";
		cout << "15. Exit\n";
		cout << "Enter choice: ";
		cin >> choice;
		system("CLS");
		switch (choice) {
		case 1: {
			int id; string cname, pickup, drop; float fare;
			cout << "Enter ID, Customer Name, Pickup, Drop, Fare: ";
			cin >> id >> cname >> pickup >> drop >> fare;
			int date, month, year = 0;
			cout << "Enter Date ( DD/MM/YYYY): ";
			cin >> date >> month >> year;
			id = system2.getUniqueID(id);
			system2.addRideRequest(id, cname, pickup, drop, fare, Date(date,month,year));
			break;
		}
		case 2: {
			int id;
			cout << "Enter Ride ID to cancel: ";
			cin >> id;
			system2.cancelRideRequest(id);
			break;
		}
		case 3: {
			int id; string dname;
			cout << "Enter Ride ID and Driver Name: ";
			cin >> id >> dname;
			system2.assignRideToDriver(id, dname);
			break;
		}
		case 4: {
			int id; bool completed;
			cout << "Enter Ride ID and (1 for Completed, 0 forCanceled): ";
			cin >> id >> completed;
			system2.completeRide(id, completed);
			break;
		}
		case 5: system2.displayRideRequests(); break;
		case 6: system2.displayActiveRides(); break;
		case 7: system2.displayRideHistory(); break;
		case 8: {
			string cname;
			cout << "Enter Customer Name: ";
			cin >> cname;
			system2.searchRideByCustomer(cname);
			break;
		}

		case 9: system2.calculateTotalRevenue(); break;
		case 10: system2.sortRideHistoryByFare(); break;
		case 11: system2.reverseRideHistory(); break;
		case 12: system2.detectAndMergeDuplicateRequests(); break;
		case 13: {

				cout << "Enter Date (DD/MM/YYYY): ";
				int day, month, year = 0;
				cin >> day >> month >> year;
				Date date(day, month, year);
				system2.deleteOldRidesByDate(date);
				break;
			}
		case 14: system2.findLongestRide(); break;
		case 15: cout << "Exiting...\n"; break;
		default: cout << "Invalid choice!\n";
		}
	} while (choice != 15);
	return 0;

	//ensure that when rides transfer between one another, they are removed from the source



}

#include<iostream>
#include<cstdlib>
using namespace std;


class Date {
private:
	int month;
	int date;
	int year;
public:
	Date() {
		month = 0;
		year = 0;
		date = 0;
	}

	Date(int date, int month, int year) {
		this->date = date;
		this->month = month;
		this->year = year;
	}
	void Display() {
		cout << endl << "Date: " << date << "/" << month << "/" << year << endl;
	}


	bool operator<(const Date& b) const {
		if (this->year < b.year) {
			return true;
		}
		else if (this->year == b.year) {
			if (this->month < b.month) {
				return true;
			}
			else if (this->month == b.month) {
				if (this->date < b.date) {
					return true;
				}
			}
		}

		return false;
	}


};

class Ride {
private:
	string customerName;
	string pickup;
	string dropoff;
	float fare;
	Date date;
public:
	Ride() {
		customerName = "";
		this->pickup = "";
		dropoff = "";
		this->fare = 0;
		date = Date();
	}
	Ride(string cname, string pickup, string drop, float fare, Date date) {

		customerName = cname;
		this->pickup = pickup;
		dropoff = drop;
		this->fare = fare;

		this->date = date;
	}
	//Getters
	string getCustomerName() {
		return customerName;
	}
	string getDropOffLocation() {
		return dropoff;
	}
	string getPickUPLocation() {
		return pickup;
	}
	Date& getDate() {
		return date;
	}
	float getFare() {
		return fare;
	}

	virtual void Display() {
		date.Display();
		cout << "\nCustomer Name: " << getCustomerName() << endl;
		cout << "\nPickup Location: " << getPickUPLocation() << endl;
		cout << "\nDropoff Location: " << getDropOffLocation() << endl;
		cout << "\nFare: " << getFare() << endl;
		cout << "---------------------------";
	}
};
class RideRequest : public Ride {
	int requestID;
public:

	RideRequest() {
		requestID = 0;
	}
	RideRequest(int id, string cname, string pickup, string drop, float fare, Date date) : Ride(cname, pickup, drop, fare,date) {
		requestID = id;
	}

	int getRideRequestID() {
		return requestID;
	}

	void Display() override {
		cout << "\n----------------\nRequest ID: " << requestID << endl;
		Ride::Display();
	}


};

// Node structure for Active Rides
class ActiveRide : public Ride {
	int rideID;
	string driverName;
public:
	ActiveRide() : Ride() {
		rideID = 0;
		driverName = "";
	}
	ActiveRide(int id, string driverName, RideRequest& obj) : Ride(obj.getCustomerName(), obj.getDropOffLocation(), obj.getDropOffLocation(), obj.getFare(), obj.getDate()) {
		rideID = id;
		this->driverName = driverName;
	}


	void Display() override {
		cout << endl << "----------------\nRide ID: " << rideID << endl << "Driver Name: " << driverName << endl;
		Ride::Display();

	}

	int getrideID() {
		return rideID;
	}
	string getdriverName() {
		return driverName;
	}

};
// Node structure for Ride History
class RideHistory : public Ride {
	int rideID;
	string driverName;
	bool status; // Completed or Canceled
public:
	RideHistory() : Ride() {
		rideID = 0;
		driverName = "";
		status = "";
	}
	RideHistory(bool status, int id, string driverName, string cname, string pickup, string drop, float fare,Date date) : Ride(cname, pickup, drop, fare, date) {
		rideID = id;
		this->driverName = driverName;
		this->status = status;
	}

	RideHistory(int id, RideRequest& obj) : Ride(obj.getCustomerName(), obj.getPickUPLocation(), obj.getDropOffLocation(), obj.getFare(), obj.getDate()) {
		// status will be cancelled
		//driver will not be assigned
		rideID = obj.getRideRequestID();
		status = 0;
		driverName = "Not assigned";
	}


	RideHistory(bool status, int id, ActiveRide& obj) : Ride(obj.getCustomerName(), obj.getPickUPLocation(), obj.getDropOffLocation(), obj.getFare(), obj.getDate()) {
		// status will be cancelled
		//driver will not be assigned
		rideID = obj.getrideID();
		this->status = status;
		driverName = obj.getdriverName();
	}

	void Display() override {
		cout << endl << "----------------\nRide ID: " << rideID << endl << "Driver Name: " << driverName << endl << "Ride status: " << status;
		if (status) cout << "Completed";
		else cout << endl << "Cancelled" << endl;
		Ride::Display();

	}

	int getrideID() {
		return rideID;
	}
	string getdriverName() {
		return driverName;
	}
	bool getStatus() {
		return status;
	}


};









class GenericLinkList {
protected:
	template<typename T>
	class Node {
	public:
		T obj;
		Node<T>* next;


		Node() {
			next = nullptr;
		}
		Node(T val) {
			obj = val;
			next = nullptr;
		}
	};








	template<typename T>
	bool isEmpty(Node<T>* header) {
		return header == nullptr;
	}

	template<typename T>
	void AddAtEnd(Node<T>*& header, Node<T>*& tail, T obj) {
		Node<T>* temp = new Node<T>(obj);
		if (header == nullptr) {
			header = tail = temp;
		}
		else {
			tail->next = temp;
			tail = temp;
		}
	}

	template<typename T>
	void DeleteFromStart(Node<T>*& header, Node<T>*& tail) {
		if (header == nullptr) {
			return;
		}
		else if (header->next == nullptr) {
			delete header;
			header = tail = nullptr;
		}
		else {
			Node<T>* temp = header;
			header = header->next;
			delete temp;

		}
	}



	template<typename T>
	void Display(Node<T>* header, Node<T>* tail) {
		static_assert(is_same_v<T, RideRequest> ||is_same_v<T, ActiveRide> ||is_same_v<T, RideHistory>,"Type not supported");


		if (header == nullptr) {
			cout << endl << "Empty!" << endl;
			return;
		}
		Node<T>* temp = header;
		Ride* ptr;
		while (temp != nullptr) {
			ptr = &temp->obj;
			ptr->Display();

			temp = temp->next;
		}

	}



	template<typename T>
	void Destructor(Node<T>*& header, Node<T>*& tail) {
		if (isEmpty(header)) {
			return;
		}
		Node<T>* current = header->next;
		Node<T>* prev = header;
		if (header->next == nullptr) {
			delete header;

			header = tail = nullptr;
		}
		else {

			while (current->next != nullptr) {
				delete prev;
				prev = current;
				current = current->next;


			}
		}






	}

};

template<typename T>
class Node {
public:
	T obj;
	Node<T>* next;


	Node() {
		next = nullptr;
	}
	Node(T val) {
		obj = val;
		next = nullptr;
	}
};


class RideNowSystem : protected GenericLinkList {
private:

	Node<RideRequest>* requestHead;
	Node<ActiveRide>* activeHead;
	Node<RideHistory>* historyHead;

	Node<RideRequest>* requestTail;
	Node<ActiveRide>* activeTail;
	Node<RideHistory>* historyTail;

	Node<RideRequest>* PopRequest(int id) {
		if (isEmpty(requestHead)) {
			cout << endl << "Error! List empty";
			return nullptr;
		}
		if (requestHead->obj.getRideRequestID() == id) {
			Node<RideRequest>* temp = requestHead;
			if (requestHead->next == nullptr) {
				requestHead = requestTail = nullptr;
				return temp;
			}
			else {
				requestHead = temp->next;
				return temp;
			}
		}
		else {
			if (requestHead->next == nullptr) {
				cout << endl << "List does not contain value";
				return nullptr;
			}
			Node<RideRequest>* prev = requestHead;
			Node<RideRequest>* curr = requestHead->next;
			while (curr != nullptr) {
				if (curr->obj.getRideRequestID() == id) {
					prev->next = curr->next;
					if (requestTail == curr) {
						requestTail = prev;
					}
					return curr;
				}
				else {
					prev = curr;
					curr = curr->next;
				}
			}
			cout << endl << "Couldn't  delete";
			return nullptr;



		}
	}
	Node<ActiveRide>* getActiveRides(int id) {
		if (isEmpty(activeHead)) {
			cout << endl << "Error! List empty";
			return nullptr;
		}
		else if (activeHead->obj.getrideID() == id) {
			if (activeHead->next == nullptr) {
				Node<ActiveRide>* temp = activeHead;
				activeHead = activeTail = nullptr;
				return temp;
			}
			else {
				Node<ActiveRide>* temp = activeHead;
				activeHead = temp->next;
				return temp;
			}
		}
		else {

			if (activeHead->next == nullptr) {
				cout << endl << "List does not contain value";
				return nullptr;
			}
			Node<ActiveRide>* prev = activeHead;
			Node<ActiveRide>* curr = activeHead->next;
			while (curr != nullptr) {
				if (curr->obj.getrideID() == id) {
					prev->next = curr->next;
					if (curr == activeTail) {
						activeTail = prev;
					}
					return curr;
				}
				else {
					prev = curr;
					curr = curr->next;
				}
			}
			cout << endl << "Couldn't  find ride";
			return nullptr;



		}

	}

	bool isRequestIDUnique(int id) {
		if (isEmpty(requestHead)) {
			return true;
		}
		else if (requestTail->obj.getRideRequestID() == id) {
			return false;
		}

		Node<RideRequest>* temp = requestHead;
		while (temp->next != nullptr) {
			if (temp->obj.getRideRequestID() == id) {
				return false;
			}
			temp = temp->next;
		}
		return true;


	}
	bool isRideIDUnique_Active(int id) {
		if (isEmpty(activeHead)) {
			return true;
		}
		else if (activeTail->obj.getrideID() == id) {
			return false;
		}

		Node<ActiveRide>* temp = activeHead;
		while (temp->next != nullptr) {
			if (temp->obj.getrideID() == id) {
				return false;
			}
			temp = temp->next;
		}
		return true;
	}
	bool isRideIDUnique_History(int id) {
		if (isEmpty(activeHead)) {
			return true;
		}
		else if (activeTail->obj.getrideID() == id) {
			return false;
		}

		Node<ActiveRide>* temp = activeHead;
		while (temp->next != nullptr) {
			if (temp->obj.getrideID() == id) {
				return false;
			}
			temp = temp->next;
		}
		return true;
	}


	template<typename T>
	void Swap(Node<T>* a, Node<T>* b) {
		T dt = a->obj;
		a->obj = b->obj;
		b->obj = dt;

	}


public:
	RideNowSystem() {
		requestHead = requestTail = nullptr;
		activeHead = activeTail = nullptr;
		historyHead = historyTail = nullptr;

	}


	int getUniqueID(int& id) {
		if (isRequestIDUnique(id)) {
			return id;
		}
		else {
			do {
				cout << endl << "ID must be unique. Please try again:";
				cin >> id;
			} while (!isRequestIDUnique(id));
			return id;
		}
	}





	///
	// ========== Ride Request Functions ==========
	void addRideRequest(int id, string cname, string pickup, string drop, float fare, Date date) {
		AddAtEnd<RideRequest>(requestHead, requestTail, RideRequest(id, cname, pickup, drop, fare, date));
	}
	void displayRideRequests() {
		cout << endl << "Ride Requests list:\n";
		Display<RideRequest>(requestHead, requestTail);
	}

	void cancelRideRequest(int id) {// did not make generic function because the paremeters for delete by value are different
		if (isEmpty(requestHead)) {
			cout << endl << "List Empty! Cannot delete";
			return;
		}

		bool deleted = false;

		if (requestHead->obj.getRideRequestID() == id) {
			AddAtEnd<RideHistory>(historyHead, historyTail, RideHistory(0, requestHead->obj));
			if (requestHead->next == nullptr) {
				delete requestHead;
				requestHead = requestTail = nullptr;
				deleted = true;
			}
			else {
				Node<RideRequest>* temp = requestHead;
				requestHead = requestHead->next;
				delete temp;
			}

		}
		else {
			Node<RideRequest>* curr = requestHead->next;
			Node<RideRequest>* prev = requestHead;

			while (curr != nullptr) {
				if (curr->obj.getRideRequestID() == id) {
					prev->next = curr->next;
					AddAtEnd<RideHistory>(historyHead, historyTail, RideHistory(0, curr->obj));
					delete curr;
					cout << endl << "Request Cancelled";
					return;
				}
				prev = curr;
				curr = curr->next;
			}
			cout << endl << "Value not found!";

		}


	}


	//
	//// ========== Active Ride Functions ==========National University of Computer and Emerging Sciences,
	void assignRideToDriver(int id, string driverName) {
		Node<RideRequest>* temp = PopRequest(id);
		if (temp != nullptr) {
			AddAtEnd<ActiveRide>(activeHead, activeTail, ActiveRide(id, driverName, temp->obj));
			cout << endl << "Rider assigned!";
		}
		else {
			cout << endl << " Ride does not exist!";
		}
	}
	void displayActiveRides() {
		cout << endl << "Active Rides List:\n";
		Display<ActiveRide>(activeHead, activeTail);
	}
	//// ========== Ride History Functions ==========
	void completeRide(int id, bool completed) {
		Node<ActiveRide>* temp = getActiveRides(id);
		if(temp != nullptr){
			AddAtEnd<RideHistory>(historyHead, historyTail, RideHistory(completed, id, temp->obj));
			cout << endl << "Ride completion successful";
			return;
		}
		cout << endl <<"Ride completion unsuccessful";

		
	}
	void displayRideHistory() {
		Display<RideHistory>(historyHead, historyTail);
	}
	void searchRideByCustomer(string cname) {
		if (isEmpty(historyHead)) {
			cout << endl << "List empty";
			return;
		}

		Node<RideHistory>* temp = historyHead;
		bool found = false;
		while (temp != nullptr) {
			if (temp->obj.getCustomerName() == cname) {
				cout << endl << "Ride found!\nRide Details:";
				temp->obj.Display();
				found = true;
			}
			temp = temp->next;
		}
		if (!found) {
			cout << endl << "Ride not found";
		}
	}
	void calculateTotalRevenue() {
		float rev = 0;
		if (isEmpty(historyHead)) {
			cout << endl << "Total Revenue: " << rev;
		}
		else if (historyHead->next == nullptr) {
			rev = historyHead->obj.getFare();
		}
		else {
			Node<RideHistory>* temp = historyHead;
			while (temp != nullptr) {
				rev += temp->obj.getFare();
				temp = temp->next;
			}
		}

		cout << endl << "Total Revenue: " << rev;
	}
	//// ========== Advanced Functionalities ==========
	void sortRideHistoryByFare() {
		if (isEmpty(historyHead)) {
			cout << endl << "History List empty";
			return;
		}

		Node<RideHistory>* max = historyHead;
		while (max->next != nullptr) {
			Node<RideHistory>* max2 = historyHead;
			while (max2->next != nullptr) {
				if (max2->obj.getFare() < max2->next->obj.getFare()) {
					Swap(max2, max2->next);
				}
				max2 = max2->next;
			}
			max = max->next;
		}
	}
	void reverseRideHistory() {
		if (isEmpty(historyHead)) {
			cout << endl << "History List empty";
			return;
		}

		Node<RideHistory>* max = historyHead;
		while (max->next != nullptr) {
			Node<RideHistory>* max2 = historyHead;
			while (max2->next != nullptr) {
				if (max2->obj.getDate().operator<(max2->next->obj.getDate())) {

					Swap(max2, max2->next);
				}
				max2 = max2->next;
			}
			max = max->next;
		}
	
	}


	void deleteOldRidesByDate(Date date) {
		if (isEmpty(historyHead)) {
			cout << endl << "List empty!";
			return;
		}

		// Step 1: Remove from the start while head is old
		while (historyHead != nullptr && historyHead->obj.getDate() < date) {
			DeleteFromStart<RideHistory>(historyHead, historyTail);
		}

		Node<RideHistory>* prev = historyHead;
		Node<RideHistory>* curr = (prev != nullptr) ? prev->next : nullptr;

		while (curr != nullptr) {
			if (curr->obj.getDate() < date) {
				prev->next = curr->next;
				if (curr == historyTail) {
					historyTail = prev;
				}
				delete curr;
				curr = prev->next;
			}
			else {
				prev = curr;
				curr = curr->next;
			}
		}
	}

	// Extra challenge
	void findLongestRide() {
		if (isEmpty(historyHead)) {
			cout << endl << "No rides";
			return;
		}
		int max = 0;
		Node<RideHistory>* temp = historyHead;
		Node<RideHistory>* mak = historyHead;
		string str = "";

		while (temp != nullptr) {
			str.append(temp->obj.getPickUPLocation());
			str.append(temp->obj.getDropOffLocation());
			if (str.size() > max) {
				mak = temp;
				max = str.size();
			}
			str.clear();
			temp = temp->next;
		}

		cout << endl << "Longest Ride:";
		mak->obj.Display();

	}

	void detectAndMergeDuplicateRequests() {
		if (isEmpty(requestHead)) {
			cout << endl << "List empty!";
			return;
		}
		Node<RideRequest>* temp = requestHead;

		while (temp != nullptr) {
			Node<RideRequest>* prev = temp;
			Node<RideRequest>* curr = temp->next;

			while (curr != nullptr) {
				if (curr->obj.getPickUPLocation() == temp->obj.getPickUPLocation() &&curr->obj.getDropOffLocation() == temp->obj.getDropOffLocation() &&curr->obj.getCustomerName() == temp->obj.getCustomerName()) {
					prev->next = curr->next;
					if (curr == requestTail) {
						prev = requestTail;
					}
					delete curr;
					curr = prev->next;
				}
				else {
					prev = curr;
					curr = curr->next;
				}
			}

			temp = temp->next;
		}
	}


	~RideNowSystem() {
	
		if (!isEmpty(requestHead))Destructor<RideRequest>(requestHead, requestTail);
		if (!isEmpty(activeHead))Destructor<ActiveRide>(activeHead, activeTail);
		if (!isEmpty(historyHead))Destructor<RideHistory>(historyHead, historyTail);
	}




};


void IsDateValid(int& date, int& month, int& year) {
	if (month > 12 || month < 1) {
		do {
			cout << endl << "Invalid input. Month must me between 1 - 12";
			cin >> month;

		} while (month < 1 || month > 12);
	}
	if (month % 2 == 0 && month < 7) {
		if (date > 30) {
			do {
				cout << endl << "The date ranges from 1-30. Please choose appropriately";
				cin >> date;
			} while (date > 30);
		}
	}
	if (month % 2 != 0 && month <= 7) {
		if (date > 31) {
			do {
				cout << endl << "The date ranges from 1-31. Please choose appropriately";
				cin >> date;
			} while (date > 30);
		}
	}

	if (month % 2 == 0 && month >= 8 && month) {
		if (date > 31) {
			do {
				cout << endl << "The date ranges from 1-31. Please choose appropriately";
				cin >> date;
			} while (date > 31);
		}
	}
	if (month % 2 != 0 && month >= 8 && month) {
		if (date > 30) {
			do {
				cout << endl << "The date ranges from 1-31. Please choose appropriately";
				cin >> date;
			} while (date > 30);
		}
	}



	if (year % 2 == 0 && month == 2 && date > 28) {
		do {
			cout << endl << "Month 2 consists of 28 days.\nEnter correct date:";
			cin >> date;
		} while (date > 28);
	}
}
int main() {

	RideNowSystem system2;
	system2.addRideRequest(1, "Ahmed", "", "dgndlfgn", 55, Date(2,12,2000));
	system2.addRideRequest(2, "Ali", "adfasdf", "jfgndfg", 23, Date(3,1,2001));
	system2.addRideRequest(3, "Haseeb", "astolfo", "andfjgn", 99 ,Date(5, 1, 2001));
	system2.addRideRequest(4, "Dan", "sdfasdf", "jndfijg", 6, Date(8, 11, 2002));
	system2.addRideRequest(5, "E", "jijij", "dgndlfgn", 5, Date(9, 1, 2003));
	system2.addRideRequest(6, "Ahmed", "jijij", "dgndlfgn", 55, Date(2, 12, 2003));
	system2.addRideRequest(7, "B", "adfasdf", "jfsfgdfg", 23, Date(3, 1, 2004));
	system2.addRideRequest(8, "C", "astolfo", "andfjgn", 99, Date(5, 1, 2005));
	system2.addRideRequest(9, "D", "sdfasdf", "jndfijg", 6, Date(8, 11, 2005));
	system2.addRideRequest(10, "E", "jijij", "dgndlfgn", 5, Date(9, 1, 2006));


	int choice;
	do {
		cout << "\n====== RideNow System Menu ======\n";
		cout << "1. Add Ride Request\n";
		cout << "2. Cancel Ride Request\n";
		cout << "3. Assign Ride to Driver\n";
		cout << "4. Complete Ride\n";
		cout << "5. Display Current Ride Requests\n";
		cout << "6. Display Active Rides\n";
		cout << "7. Display Ride History\n";
		cout << "8. Search Rides by Customer\n";
		cout << "9. Calculate Total Revenue\n";
		cout << "10. Sort Ride History by Fare\n";
		cout << "11. Reverse Ride History\n";
		cout << "12. Detect & Merge Duplicate Ride Requests\n";
		cout << "13. Delete Old Rides by Date\n";
		cout << "14. Find Longest Ride\n";
		cout << "15. Exit\n";
		cout << "Enter choice: ";
		cin >> choice;
		system("CLS");
		switch (choice) {
		case 1: {
			int id; string cname, pickup, drop; float fare;
			cout << "Enter ID, Customer Name, Pickup, Drop, Fare: ";
			cin >> id >> cname >> pickup >> drop >> fare;
			int date, month, year = 0;
			cout << "Enter Date ( DD/MM/YYYY): ";
			cin >> date >> month >> year;
			id = system2.getUniqueID(id);
			system2.addRideRequest(id, cname, pickup, drop, fare, Date(date,month,year));
			break;
		}
		case 2: {
			int id;
			cout << "Enter Ride ID to cancel: ";
			cin >> id;
			system2.cancelRideRequest(id);
			break;
		}
		case 3: {
			int id; string dname;
			cout << "Enter Ride ID and Driver Name: ";
			cin >> id >> dname;
			system2.assignRideToDriver(id, dname);
			break;
		}
		case 4: {
			int id; bool completed;
			cout << "Enter Ride ID and (1 for Completed, 0 forCanceled): ";
			cin >> id >> completed;
			system2.completeRide(id, completed);
			break;
		}
		case 5: system2.displayRideRequests(); break;
		case 6: system2.displayActiveRides(); break;
		case 7: system2.displayRideHistory(); break;
		case 8: {
			string cname;
			cout << "Enter Customer Name: ";
			cin >> cname;
			system2.searchRideByCustomer(cname);
			break;
		}

		case 9: system2.calculateTotalRevenue(); break;
		case 10: system2.sortRideHistoryByFare(); break;
		case 11: system2.reverseRideHistory(); break;
		case 12: system2.detectAndMergeDuplicateRequests(); break;
		case 13: {

				cout << "Enter Date (DD/MM/YYYY): ";
				int day, month, year = 0;
				cin >> day >> month >> year;
				IsDateValid(day, month, year);
				Date date(day, month, year);
				system2.deleteOldRidesByDate(date);
				break;
			}
		case 14: system2.findLongestRide(); break;
		case 15: cout << "Exiting...\n"; break;
		default: cout << "Invalid choice!\n";
		}
	} while (choice != 15);
	return 0;



}

#include<iostream>
#include<cstdlib>
using namespace std;
//Node structure for Ride Requests


class Date {
private:
	int month;
	int date;
	int year;
public:
	Date() {
		month = 0;
		year = 0;
		date = 0;
	}

	Date(int date, int month, int year) {
		this->date = date;
		this->month = month;
		this->year = year;
	}
	void Display() {
		cout << endl << "Date: " << date << "/" << month << "/" << year << endl;
	}

	bool operator<(Date& b) {
		if (this->year > b.year) {
			return true;
		}
		else if(b.year == this->year) {
			if (this->month > b.month) {
				return true;
			}
			else if (b.date == this->date) {
				if (this->date > b.date) {
					return true;
				}
			}


		}
		return false;
	}

};
class Ride {
private:
	string customerName;
	string pickup;
	string dropoff;
	float fare;
	Date date;
public:
	Ride() {
		customerName = "";
		this->pickup = "";
		dropoff = "";
		this->fare = 0;
		date = Date();
	}
	Ride(string cname, string pickup, string drop, float fare, Date date) {

		customerName = cname;
		this->pickup = pickup;
		dropoff = drop;
		this->fare = fare;

		this->date = date;
	}
	//Getters
	string getCustomerName() {
		return customerName;
	}
	string getDropOffLocation() {
		return dropoff;
	}
	string getPickUPLocation() {
		return pickup;
	}
	Date getDate() {
		return date;
	}
	float getFare() {
		return fare;
	}

	virtual void Display() {
		date.Display();
		cout << "\nCustomer Name: " << getCustomerName() << endl;
		cout << "\nPickup Location: " << getPickUPLocation() << endl;
		cout << "\nDropoff Location: " << getDropOffLocation() << endl;
		cout << "\nFare: " << getFare() << endl;
		cout << "---------------------------";
	}
};
class RideRequest : public Ride {
	//making a template for displaying the lists makes sense cosidering the only major difference in the code will be
	//of the object's own display function
private:
	int requestID;
public:

	RideRequest() {
		requestID = 0;
	}
	RideRequest(int id, string cname, string pickup, string drop, float fare, Date date) : Ride(cname, pickup, drop, fare,date) {
		requestID = id;
	}

	int getRideRequestID() {
		return requestID;
	}

	void Display() override {
		cout << "\n----------------\nRequest ID: " << requestID << endl;
		Ride::Display();// this saves sooo much time tho
	}


};

// Node structure for Active Rides
class ActiveRide : public Ride {
	int rideID;
	string driverName;
public:
	// active rides objectss are created when a request is accepted
	//its existence depends upon RideRequest
	//ActiveRide(int id, string driverName, string cname, string pickup, string drop, float fare) : Ride(cname, pickup, drop, fare){
	//	rideID = id;
	//	this->driverName = driverName;
	//}
	ActiveRide() : Ride() {
		rideID = 0;
		driverName = "";
	}
	ActiveRide(int id, string driverName, RideRequest& obj) : Ride(obj.getCustomerName(), obj.getDropOffLocation(), obj.getDropOffLocation(), obj.getFare(), obj.getDate()) {
		rideID = id;
		this->driverName = driverName;
	}


	void Display() override {
		cout << endl << "----------------\nRide ID: " << rideID << endl << "Driver Name: " << driverName << endl;
		Ride::Display();

	}

	int getrideID() {
		return rideID;
	}
	string getdriverName() {
		return driverName;
	}

};
// Node structure for Ride History
class RideHistory : public Ride {
	int rideID;
	string driverName;
	string status; // Completed or Canceled
public:
	RideHistory() : Ride() {
		rideID = 0;
		driverName = "";
		status = "";
	}
	RideHistory(string status, int id, string driverName, string cname, string pickup, string drop, float fare,Date date) : Ride(cname, pickup, drop, fare, date) {
		rideID = id;
		this->driverName = driverName;
		this->status = status;
	}

	RideHistory(int id, RideRequest& obj) : Ride(obj.getCustomerName(), obj.getPickUPLocation(), obj.getDropOffLocation(), obj.getFare(), obj.getDate()) {
		// status will be cancelled
		//driver will not be assigned
		rideID = id;
		status = "cancelled";
		driverName = "Not assigned";
	}


	RideHistory(bool status, int id, ActiveRide& obj) : Ride(obj.getCustomerName(), obj.getPickUPLocation(), obj.getDropOffLocation(), obj.getFare(), obj.getDate()) {
		// status will be cancelled
		//driver will not be assigned
		rideID = id;
		this->status = status;
		driverName = obj.getdriverName();
	}

	void Display() override {
		cout << endl << "----------------\nRide ID: " << rideID << endl << "Driver Name: " << driverName << endl << "Ride status: " << status << endl;
		Ride::Display();

	}

	int getrideID() {
		return rideID;
	}
	string getdriverName() {
		return driverName;
	}
	string getStatus() {
		return status;
	}


};






template<typename T>
class Node {
public:
	T obj;
	Node<T>* next;


	Node() {
		next = nullptr;
	}
	Node(T val) {
		obj = val;
		next = nullptr;
	}


};


// class contains generic functions that the three lists can use, and their functionalities are not that differnt.
//why can I not make header and tail pointers?
//Because the type is defined by the child class
// If I make this into a class template, I'll need the data type when I make the child class
//One solution could be to make a single parent class
//Children wil contain members unique to them
class GenericLinkList {
protected:
	//Generic functions
	// why did you not make this into a class?
	// because making this into a class, had me making specialized functions that defeated the purpose of making it into a class
	template<typename T>
	bool isEmpty(Node<T>* header) {
		return header == nullptr;
	}

	template<typename T>
	void AddAtEnd(Node<T>*& header, Node<T>*& tail, T obj) {
		Node<T>* temp = new Node<T>(obj);
		if (header == nullptr) {
			header = tail = temp;
		}
		else {
			tail->next = temp;
			tail = temp;
		}
	}
	template<typename T>
	void Display(Node<T>* header, Node<T>* tail) {
		static_assert(
			is_same_v<T, RideRequest> ||
			is_same_v<T, ActiveRide> ||
			is_same_v<T, RideHistory>,
			"Type not supported"
			);


		if (header == nullptr) {
			cout << endl << "Empty!" << endl;
			return;
		}
		Node<T>* temp = header;
		Ride* ptr;
		while (temp != nullptr) {
			ptr = &temp->obj;
			ptr->Display();

			temp = temp->next;
		}
		//ptr = &temp->obj;
		//ptr->Display();

	}



	template<typename T>
	void Destructor(Node<T>*& header, Node<T>*& tail) {
		if (isEmpty(header)) {
			return;
		}
		Node<T>* current = header->next;
		Node<T>* prev = header;
		if (header->next == nullptr) {
			delete header;

			header = tail = nullptr;
		}
		else {

			while (current->next != nullptr) {
				delete prev;
				prev = current;
				current = current->next;


			}
		}






	}

	template<typename T>
	void DeleteFromEnd(Node<T>*& header, Node<T>*& tail) {
		if (isEmpty(header)) {
			cout << endl << "Empty" << endl;
			return;
		}

		if (header->next == nullptr) {
			delete header;
			header = tail = nullptr;
			return;
		}
		Node<T>* temp = header;
		while (temp->next != tail) {
			temp = temp->next;
		}

		delete tail;
		tail = temp;
		tail->next = nullptr;

	}



	/*template<typename T>
	int SearchElement(t val) {

		if (isEmpty()) {
			return -1;
		}

		if (header->data == val) {
			return 0;
		}
		else {
			Node<t>* temp = header->next;
			int i = 1;
			while (temp->next != nullptr) {
				if (temp->data == val) {
					return i;
				}

				i++;
				temp = temp->next;
			}
			if (temp->data == val) {
				return i;
			}

		}

		return -1;
	}*/

	// Helper functions that cannot be generalized

};

class RideNowSystem : protected GenericLinkList {
private:
	Node<RideRequest>* requestHead;
	Node< ActiveRide>* activeHead;
	Node< RideHistory>* historyHead;

	Node<RideRequest>* requestTail;
	Node<ActiveRide>* activeTail;
	Node<RideHistory>* historyTail;


	Node<RideRequest>* getRequest(int id) { // make the delete function here for the time being
		if (isEmpty(requestHead)) {
			cout << endl << "Error! List empty";
		}
		else if (requestHead->obj.getRideRequestID() == id) {
			return requestHead;
		}
		else if (requestTail->obj.getRideRequestID() == id) {
			return requestTail;
		}
		else {
			if (requestHead->next == nullptr) {
				cout << endl << "List does not contain value";
				return nullptr;
			}
			Node<RideRequest>* temp = requestHead->next;
			while (temp->next != nullptr) {
				if (temp->obj.getRideRequestID() == id) {
					return temp;
				}
				temp = temp->next;
			}

			return nullptr;



		}
	}
	Node<RideRequest>* PopRequest(int id) {
		if (isEmpty(requestHead)) {
			cout << endl << "Error! List empty";
		}
		else if (requestHead->obj.getRideRequestID() == id) {
			if (requestHead->next == nullptr) {
				Node<RideRequest>* temp = new Node<RideRequest>();
				temp->obj = requestHead->obj;
				delete requestHead;
				requestHead = requestTail = nullptr;
				return temp;
			}
		}
		else {
			if (requestHead->next == nullptr) {
				cout << endl << "List does not contain value";
				return nullptr;
			}
			Node<RideRequest>* prev = requestHead;
			Node<RideRequest>* curr = requestHead->next;
			while (curr->next != nullptr) {
				if (curr->obj.getRideRequestID() == id) {
					prev->next = curr->next;
					Node<RideRequest>* temp = new Node<RideRequest>();
					temp->obj = curr->obj;
					delete curr;
					return temp;
				}
				prev = curr;
				curr = curr->next;
			}
			cout << endl << "Couldn't  delete";
			return nullptr;



		}
	}

	Node<ActiveRide>* getActiveRides(int id) {
		if (isEmpty(activeHead)) {
			cout << endl << "Error! List empty";
		}
		else if (activeHead->obj.getrideID() == id) {
			if (activeHead->next == nullptr) {
				Node<ActiveRide>* temp = new Node<ActiveRide>();
				temp->obj = activeHead->obj;
				delete activeHead;
				activeHead = activeTail = nullptr;
				return temp;
			}
		}
		else {
			if (activeHead->next == nullptr) {
				cout << endl << "List does not contain value";
				return nullptr;
			}
			Node<ActiveRide>* prev = activeHead;
			Node<ActiveRide>* curr = activeHead->next;
			while (curr->next != nullptr) {
				if (curr->obj.getrideID() == id) {
					prev->next = curr->next;
					Node<ActiveRide>* temp = new Node<ActiveRide>();
					temp->obj = curr->obj;
					delete curr;
					return temp;
				}
				prev = curr;
				curr = curr->next;
			}
			cout << endl << "Couldn't  delete";
			return nullptr;



		}

	}

	template<typename T>
	void Swap(Node<T>* a, Node<T>* b) {
		static_assert(
			is_same_v<T, RideRequest> ||
			is_same_v<T, ActiveRide> ||
			is_same_v<T, RideHistory>,
			"Type not supported"
			);

		T dt = a->obj;
		a->obj = b->obj;
		b->obj = dt;

	}

	void OutputInReverse(Node<RideHistory>* ptr) {
		if (ptr->next == nullptr) {
			ptr->obj.Display();
			return;
		}
		OutputInReverse(ptr->next);

		ptr->obj.Display();

	}

public:
	RideNowSystem() {
		requestHead = requestTail = nullptr;
		activeHead = activeTail = nullptr;
		historyHead = historyTail = nullptr;

	}





	///
	// ========== Ride Request Functions ==========
	void addRideRequest(int id, string cname, string pickup, string drop, float fare, Date date) {
		AddAtEnd<RideRequest>(requestHead, requestTail, RideRequest(id, cname, pickup, drop, fare, date));
	}
	void displayRideRequests() {
		Display<RideRequest>(requestHead, requestTail);
	}

	void cancelRideRequest(int id) {// did not make generic function because the paremeters for delete by value are different
		if (isEmpty(requestHead)) {
			cout << endl << "List Empty! Cannot delete";
			return;
		}

		bool deleted = false;

		if (requestHead->obj.getRideRequestID() == id) {
			AddAtEnd<RideHistory>(historyHead, historyTail, RideHistory(0, requestHead->obj));
			if (requestHead->next == nullptr) {
				delete requestHead;
				requestHead = requestTail = nullptr;
				deleted = true;
			}
			else {
				Node<RideRequest>* temp = requestHead;
				requestHead = requestHead->next;
				delete temp;
			}

		}
		else if (requestTail->obj.getRideRequestID() == id) {
			AddAtEnd<RideHistory>(historyHead, historyTail, RideHistory(0, requestHead->obj));
			DeleteFromEnd<RideRequest>(requestHead, requestTail);
		}
		else {
			Node<RideRequest>* curr = requestHead->next;
			Node<RideRequest>* prev = requestHead;

			while (curr != nullptr) {
				if (curr->obj.getRideRequestID() == id) {
					prev->next = curr->next;
					AddAtEnd<RideHistory>(historyHead, historyTail, RideHistory(0, requestHead->obj));
					delete curr;
					cout << endl << "Request Cancelled";
					return;
				}
				prev = curr;
				curr = curr->next;
			}
			cout << endl << "Value not found!";

		}


	}


	//
	//// ========== Active Ride Functions ==========National University of Computer and Emerging Sciences,
	void assignRideToDriver(int id, string driverName) {
		Node<RideRequest>* temp = PopRequest(id);
		if (temp != nullptr) {
			AddAtEnd<ActiveRide>(activeHead, activeTail, ActiveRide(id, driverName, temp->obj));
		}
		else {
			cout << endl << " Ride does not exist!";
		}
	}
	void displayActiveRides() {
		cout << endl << "Active Rides List:\n";
		Display<ActiveRide>(activeHead, activeTail);
	}
	//// ========== Ride History Functions ==========
	void completeRide(int id, bool completed) {
		Node<ActiveRide>* temp = getActiveRides(id);
		AddAtEnd<RideHistory>(historyHead, historyTail, RideHistory(completed, id, temp->obj));
	}
	void displayRideHistory() {
		Display<RideHistory>(historyHead, historyTail);
	}
	void searchRideByCustomer(string cname) {
		if (isEmpty(historyHead)) {
			cout << endl << "List empty";
			return;
		}

		Node<RideHistory>* temp = historyHead;
		if (temp->obj.getCustomerName() == cname) {
			cout << endl << "Ride found!\nRide Details:";
			temp->obj.Display();
		}
		else if (historyTail->obj.getCustomerName() == cname) {
			cout << endl << "Ride found!\nRide Details:";
			temp->obj.Display();
		}
		else {
			bool found = false;
			while (temp->next != historyTail) {
				if (temp->obj.getCustomerName() == cname) {
					cout << endl << "Ride found!\nRide Details:";
					temp->obj.Display();
					found = true;
				}
			}
			if (!found) {
				cout << endl << "Ride not found";
			}
		}
	}
	void calculateTotalRevenue() { // this could've been float but the skeleton made it void
		float rev = 0;
		if (isEmpty(historyHead)) {
			cout << endl << "Total Revenue: " << rev;
		}
		else if (historyHead->next == nullptr) {
			rev = historyHead->obj.getFare();
		}
		else {
			Node<RideHistory>* temp = historyHead;
			while (temp->next != nullptr) {
				rev += temp->obj.getFare();
				temp = temp->next;
			}
		}

		cout << endl << "Total Revenue: " << rev;
	}
	//// ========== Advanced Functionalities ==========
	void sortRideHistoryByFare() {
		if (isEmpty(historyHead)) {
			cout << endl << "History List empty";
			return;
		}

		Node<RideHistory>* max = historyHead;
		while (max->next != nullptr) {
			Node<RideHistory>* max2 = historyHead;
			while (max2->next != nullptr) {
				if (max2->obj.getFare() < max2->next->obj.getFare()) {
					Swap(max2, max2->next);
				}
				max2 = max2->next;
			}
			max = max->next;
		}
	}
	void reverseRideHistory() {
		if (isEmpty(historyHead)) {
			cout << endl << "List Empty!";
			return;
		}

		OutputInReverse(historyHead);
	}
	//void detectAndMergeDuplicateRequests() {
	//	if (isEmpty(requestHead)) {
	//		return;
	//	}

	//	if (requestHead->next == nullptr) {
	//		return;
	//	}
	//	Node<RideRequest>* temp = requestHead;

	//	while (temp != nullptr) {
	//		Node<RideRequest>* prev = temp;
	//		Node<RideRequest>* curr = temp->next;

	//		while (curr != nullptr) {
	//			if (curr->obj.getPickUPLocation() == temp->obj.getPickUPLocation() &&
	//				curr->obj.getDropOffLocation() == temp->obj.getDropOffLocation() &&
	//				curr->obj.getCustomerName() == temp->obj.getCustomerName()) {

	//				// Duplicate found → delete
	//				prev->next = curr->next;
	//				delete curr;
	//				curr = prev->next;   // ✅ safe, don’t advance prev
	//			}
	//			else {
	//				prev = curr;
	//				curr = curr->next;
	//			}
	//		}

	//		temp = temp->next;
	//	}


	//}
	//void deleteOldRidesByDate(string date); // Extra challenge
	//void findLongestRide();

	void detectAndMergeDuplicateRequests() {
		Node<RideRequest>* temp = requestHead;

		while (temp != nullptr) {
			Node<RideRequest>* prev = temp;
			Node<RideRequest>* curr = temp->next;

			while (curr != nullptr) {
				if (curr->obj.getPickUPLocation() == temp->obj.getPickUPLocation() &&
					curr->obj.getDropOffLocation() == temp->obj.getDropOffLocation() &&
					curr->obj.getCustomerName() == temp->obj.getCustomerName()) {

					// Duplicate found → delete safely
					prev->next = curr->next;
					delete curr;
					curr = prev->next;
				}
				else {
					prev = curr;
					curr = curr->next;
				}
			}

			temp = temp->next;
		}
	}







	~RideNowSystem() {
		Destructor<RideRequest>(requestHead, requestTail);
	}
};

int main() {

	RideNowSystem system2;
	system2.addRideRequest(1, "osaka", "jijij", "dgndlfgn", 55, Date(2,12,2000));
	system2.addRideRequest(2, "chiyo", "adfasdf", "jfgndfg", 23, Date(3,1,2001));
	system2.addRideRequest(3, "af", "astolfo", "andfjgn", 99 ,Date(5, 1, 2001));
	system2.addRideRequest(4, "biboo", "sdfasdf", "jndfijg", 6, Date(8, 11, 2002));
	system2.addRideRequest(1, "osaka", "jijij", "dgndlfgn", 5, Date(9, 1, 2004));

	Date bb(9, 11, 2001);
	Date flash(1, 2, 2002);

	cout << endl << (flash < bb);






	int choice;
	do {
		cout << "\n====== RideNow System Menu ======\n";
		cout << "1. Add Ride Request\n";
		cout << "2. Cancel Ride Request\n";
		cout << "3. Assign Ride to Driver\n";
		cout << "4. Complete Ride\n";
		cout << "5. Display Current Ride Requests\n";
		cout << "6. Display Active Rides\n";
		cout << "7. Display Ride History\n";
		cout << "8. Search Rides by Customer\n";
		cout << "9. Calculate Total Revenue\n";
		cout << "10. Sort Ride History by Fare\n";
		cout << "11. Reverse Ride History\n";
		cout << "12. Detect & Merge Duplicate Ride Requests\n";
		cout << "13. Delete Old Rides by Date\n";
		cout << "14. Find Longest Ride\n";
		cout << "15. Exit\n";
		cout << "Enter choice: ";
		cin >> choice;
		system("CLS");
		switch (choice) {
		case 1: {
			int id; string cname, pickup, drop; float fare;
			cout << "Enter ID, Customer Name, Pickup, Drop, Fare: ";
			cin >> id >> cname >> pickup >> drop >> fare;
			int date, month, year = 0;
			cout << "Enter Date ( DD/MM/YYYY): ";
			cin >> date >> month >> year;
			system2.addRideRequest(id, cname, pickup, drop, fare, Date(date,month,year));
			break;
		}
		case 2: {
			int id;
			cout << "Enter Ride ID to cancel: ";
			cin >> id;
			system2.cancelRideRequest(id);
			break;
		}
		case 3: {
			int id; string dname;
			cout << "Enter Ride ID and Driver Name: ";
			cin >> id >> dname;
			system2.assignRideToDriver(id, dname);
			break;
		}
		case 4: {
			int id; bool completed;
			cout << "Enter Ride ID and (1 for Completed, 0 forCanceled): ";
			cin >> id >> completed;
			system2.completeRide(id, completed);
			break;
		}
		case 5: system2.displayRideRequests(); break;
		case 6: system2.displayActiveRides(); break;
		case 7: system2.displayRideHistory(); break;
		case 8: {
			string cname;
			cout << "Enter Customer Name: ";
			cin >> cname;
			system2.searchRideByCustomer(cname);
			break;
		}

		case 9: system2.calculateTotalRevenue(); break;
		case 10: system2.sortRideHistoryByFare(); break;
		case 11: system2.reverseRideHistory(); break;
		case 12: system2.detectAndMergeDuplicateRequests(); break;
			/*case 13: {
				string date;
				cout << "Enter Date (DD/MM/YYYY): ";
				cin >> date;
				system.deleteOldRidesByDate(date);
				break;
			}
			case 14: system.findLongestRide(); break;
			*/
		case 15: cout << "Exiting...\n"; break;
		default: cout << "Invalid choice!\n";
		}
	} while (choice != 15);
	return 0;

	//ensure that when rides transfer between one another, they are removed from the source























}
